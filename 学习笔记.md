# 为什么要用git？

协同修改；数据备份；版本管理（SVN采取的是增量式管理，而Git采取的是文件系统快照的方式）；权限控制（可以对每个人加入限制，对团队外的人提供的代码进行审核）；历史记录；分支管理

# Git命令行操作

## 本地库操作

### 本地库初始化：

```
命令：git init(初始化)
cd .git/(进入到git文件夹当中)

效果：-rw-r--r-- 1 Linrane 197609  23 Feb 24 09:04 HEAD
-rw-r--r-- 1 Linrane 197609 130 Feb 24 09:04 config
-rw-r--r-- 1 Linrane 197609  73 Feb 24 09:04 description
drwxr-xr-x 1 Linrane 197609   0 Feb 24 09:04 hooks/
drwxr-xr-x 1 Linrane 197609   0 Feb 24 09:04 info/
drwxr-xr-x 1 Linrane 197609   0 Feb 24 09:04 objects/
drwxr-xr-x 1 Linrane 197609   0 Feb 24 09:04 refs/


注意：不要随便删除和修改.git子目录下的东西，出问题的话本地库无法正常工作
```

### 设置签名：

```
形式
用户名：xxx
邮箱：xxx@xx.com
作用：为了区分每个开发人员
辨析：这里设置的和远程库的账号密码没有一点关系
命令：
	项目级别/仓库级别：仅在当前本地库内有效
		git config user.name tom_pro
		git config use.email goodmorning_pro@qwdd.com
		信息保存文件：./.git/config文件
		显示情况：[core]
        repositoryformatversion = 0
        filemode = false
        bare = false
        logallrefupdates = true
        symlinks = false
        ignorecase = true
		[user]
        name = tom_pro
        email = goofMorning_pro@gmail.com

	用户级别：登录当前操作系统用户有效
		git config --global user.name tom_glb
		git config --global goodmorning_pro@qwdd.com
	级别优先级
		就近原则：项目级别优于用户级别（两个级别同时存在的情况）
		只存在系统用户级别的情况下，就以系统用户级别为准
		两个都没有，不允许
```

### 基本操作：

```
1.git status：查看该工作区的文件状态

运行效果：
On branch master（无分支）

No commits yet（当前文件夹无提交的文件）

nothing to commit (create/copy files and use "git add" to track)（暂存区也没有提交的文件）

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        good.txt
(发现了一个未追踪的文件)

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   good.txt
（新建的文件放到了暂存区当中了）

On branch master
nothing to commit, working tree clean（暂存区无要提交项目，工作区暂无修改内容）

（此为你修改文件后会出现的提示）
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)（更新）
  (use "git restore <file>..." to discard changes in working directory)（放弃）
        modified:   good.txt（之前看是新文件，现在看你修改后的就会变成modified）

no changes added to commit (use "git add" and/or "git commit -a")


2.git add x:将文件添加进暂存区当中

运行效果：warning: in the working copy of 'good.txt', LF will be replaced by CRLF the next time Git touches it
（行末换行符从cf转换成crlf）

3.git rm --cached x：将文件从暂存区拿出来

运行效果：rm 'good.txt'

4.git commit x：将文件提交上去

运行效果：Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
#
# On branch master
#
# Initial commit
#
# Changes to be committed:
#       new file:   good.txt

比如你可以输入：my first commit.new file good.txt（这是我提交的第一个文件）

提交完以后会出现：

[master (root-commit) 5080633] my first commit.new file good.txt（你输入的内容）
 1 file changed, 3 insertions(+)（增加了三行内容）
 create mode 100644 good.txt（创建模式）

5.git commit -m "xxx" good.txt

运行后就不用直接进入vim编辑器当中，直接就可以提交修改日志和修改内容

（版本前进和后退）
6.git log：可以看到版本的记录

运行效果：commit 6dc40a94e2ad479721a5c43890112509f82cf78a (HEAD -> master)(当前版本)
Author: tom_pro <goofMorning_pro@gmail.com>
Date:   Tue Feb 24 10:09:04 2026 +0800

    MY SECOND COMMIT

commit 508063337d6a4de2fd070ee2896fb2998c1305d3
Author: tom_pro <goofMorning_pro@gmail.com>
Date:   Tue Feb 24 09:50:24 2026 +0800

    my first commit.new file good.txt

7.git log --pretty=oneline：每个日志只显示一行

运行效果：

a6c763c97bb9e23c8b2c29d6f6c3a655cfc3deb3 (HEAD -> master) also the test for history
95ab5252a7920534309acb846e27869c4b1d5283 for test the next version
e818afb9a3026c06f11311bb50ced6dae6dd4c48 for test history
6dc40a94e2ad479721a5c43890112509f82cf78a MY SECOND COMMIT
508063337d6a4de2fd070ee2896fb2998c1305d3 my first commit.new file good.txt


8.git log --oneline：每个日志只有一行，并且只选取一部分的哈希值

运行效果：a6c763c (HEAD -> master) also the test for history
95ab525 for test the next version
e818afb for test history
6dc40a9 MY SECOND COMMIT
5080633 my first commit.new file good.txt

9.git reflog:每个日志只有一行的情况下，标明如果想要恢复历史版本需要走几步，非常方便

运行效果：a6c763c (HEAD -> master) HEAD@{0}: commit: also the test for history
95ab525 HEAD@{1}: commit: for test the next version
e818afb HEAD@{2}: commit: for test history
6dc40a9 HEAD@{3}: commit: MY SECOND COMMIT
5080633 HEAD@{4}: commit (initial): my first commit.new file good.txt

10.（基于索引值操作）git reset --hard （哈希值）（版本前进和后退都能用）

运行结果：HEAD is now at e818afb for test history（告诉你已经返回回去了）

11.（基于^)：git reset --hard HEAD^（只能后退，想后退几次加几个“^”就行）

运行效果：HEAD is now at 95ab525 for test the next version

12.git reset --hard HEAD~n（想后退几步n就写几）

运行效果都是一样的

（题外话：soft的命令是仅仅移动本地库head指针，mixed是在本地库移动head指针并且充值暂存区，而hard的命令为head指针的移动，重置暂存区和工作区

13. 删除文件后找回
    vim aaa.txt create a new file
    git add aaa.txt : add the file
    git commit -m "new aaa.txt" aaa.txt:commit a commit
    rm aaa.txt : delete a file
    git add aaa.txt :add this action
    git commit -m "delet this file" : commit the action of deleting this file
    git status :check
    ll: check the catalog and find the file not exists.
    （这个步骤就是一个创建了文件以后删除文件并且将删除文件这个动作也保存下来的过程，之后就是要用指令来进行复原了）
    git reset --hard [hash value]:recover this file.

14.添加到暂存区的文件删除找回
	步骤还是基本差不多，还是步骤到删除动作只是add到暂存库这一步，没有commit到本地库的时候。
	只需要一步就可以解决了：git reset --hard HEAD(甚至连文件名字都不用加，因为原理就是恢复到最新的哈希值（指针所在）的地方，因为你还没commit到工作库嘛。

15.比较文件差异
	git diff [filename] ：可以显示删除和增加的部分的内容
	（注：如果直接add到暂存区的情况下再去比较就不会显示了，因为比较就是通过工作区vs暂存区）
	git diff HEAD [filename]:可以和本地库内的进行比较（如果在HEAD后面加上“^”就可以和后退的历史版本进行比较了。当然“~”也是可以的哈哈哈哈哈哈哈）
	git diff ： 如果不使用文件名的话也可以显示其中的变化，但是如果想全显示的话，那就加一个HEAD就行了
	


```

# 分支管理：

## 什么是分支：

在版本控制当中使用多条线同时推进多条任务，这个就叫分支

![[Pasted image 20260224174453.png]]

如图就是一个基本的项目的运营，master就是主干，其他的部分负责项目的其他的部分的内容去推进，并且哪怕出现了问题也不会污染到主干上去，直接删除就行了，并且出现了问题也不用停止主干，直接创建修改的补丁上去，再去合并，项目的其他部分完成了以后也可以直接和主干合并

```
1.git branch -v ：查看目前已有分支

2.git branch [branchname] ：创建一个新的分支

3.git checkout {branchname} ：切换一个分支

4.合并分支
	切换到修改的分支上（被合并，增加新内容）//你先要合并的话你就必须要先回到某分支上，再合并修改的那个上 ：git checkout master[merged branchname]
	
	执行merge命令:git merge hot_fix[newfix branchname]//就可以更新了

5.解决合并之后产生的冲突：
	（情况产生原因：比如你修改和我修改的是同一个文件几乎同一个部分的内容，那么git到底听谁的，这就需要人为决定了）
	
	合并后就会发现合并未成功进入到了一个正在合并的模式当中
	使用vim打开后出现这样的情况：
	<<<<<<< HEAD
	eeeeeeee edit by master
	=======
	（这个是当前位置所做的修改）
	eeeeeeee edit by hot_fix
	>>>>>>> hot_fix
	（这个是分支所做的修改）
	
	此时需要进行与其他作者的协商（如果存在的话），把新出现的符号删除，最后修改到满意的程度就可以了，然后还有两步
		第一步：git add [filename](上传到暂存区解除目前的状态)
		第二步：git commit -m"resolve the conflict"(日志还是需要写一下的，但是不用带文件名字)
```

# 哈希算法

本质就是明文通过加密算法转换成密文

## 特点
	长度固定
	哈希算法确定，输入数据确定，输出数据就确定
	哈希算法不可逆
	git底层采用SHA-1算法

哈希算法可以被用作检验文件，只要输出后是不一样的，那么说明文件被修改了。

# 远程库操作

## 本地上传到远程
	注册账号以后创建一个仓库
	复制仓库的html地址
		git remote add origin (html地址.git) ：在origin是名字，这个命令是为了方便记录的，可以随时调用
	git push origin master(推送上去你的项目和选择的分支)
	然后去github上查看一下发现就有了，如果没上传过可能需要输入账号和密码

## 克隆到本地
	场景 :如果说现在你需要克隆现在远程库的文件怎么办？
	首先打开项目中有个code，里面有个url复制下来
	git clone （url）：进行克隆

## 远程库修改的拉取
	git fetch origin master ：从你的仓库中进行下载（此时执行cat发现还是查看的本地没有变化）
	git checkout origin/master ：切换到origin的master当中（此时cat发现是修改后的）
	git checkout master:切换回来
	git merge origin/master ：从远程库进行合并

## 协同开发遇到的冲突问题
	比如都是在某个板块修改内容，都是要提交到远程库
	如果已经有人修改并提交的情况下，这时候就push不上去了，就必须先pull下来（git pull origin master），进入merging状态
	解决方法和之前遇到冲突的方法一样

## 跨团队协作
	首先需要让另个团队的人获取clone的地址，先用浏览器访问
	然后再forl下载，就是自己的远程库部分了，就可以先clone到本地了
	clone到本地以后自己进行一系列的修改以后先commit提交，再push到自己的远程库当中
	然后打开网站以后点击pull request中的new pull request就可以进行提交了，还会列出来你所做的修改是什么
	随后就是create pull request ，先写标题，然后写内容
	与此同时，在另一边的团队就可以通过pull request查看了，还可以在write里面进行对话评论。
	但是不能轻易合并，要先审核，从commit里面看看提交了什么东西，从files changed里面看具体做了什么修改（审核）
	最后没问题了直接merge pull request
	最后pull到本地

## SSH免密登录
	原因：win7或者以下的系统没有系统凭据来进行密码的保存，每次想要保存克隆http地址的时候在本地clone都要输入一遍账号和密码，很麻烦
	cd ~ ：进入到用户的架构当中
	rm -r .ssh/ ：移除之前的
	ssh-keygen -t rsa -C [email.com] ：记录email信息
	cd .ssh/ ：进入到ssh文件夹当中
	ll ：查看所有文件
	cat id_rsa.pub ：从中获取到信息直接复制下来
	然后github用户里面有个ssh，把复制的信息粘上，再加个标题
	回到工作区做测试，回到库里复制ssh的地址，然后git remote add orgin_ssh [地址]
	这个时候修改了文件以后用ssh地址去push就不需要密码了

声明：由于我暂时不需要eclipse和gitlab，所以后面的教程部分就不听了，学了这些东西也就够用了，其他人有需求的可以去查看完整教程视频进行学习，本人的笔记仅供参考，一切内容以视频为主，完结撒花！

